<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Remote Control Panel</title>
    <link href="{{ url_for('static', filename='css/tailwind.css') }}" rel="stylesheet">
    <style>
        :root {
            --primary-gradient: linear-gradient(135deg, #3B82F6 0%, #2563EB 100%);
            --secondary-gradient: linear-gradient(135deg, #1F2937 0%, #111827 100%);
        }

        body {
            background: #0F172A;
            background-image: radial-gradient(circle at 50% 50%, #1E293B 0%, #0F172A 100%);
            min-height: 100vh;
        }

        /* Modern scrollbar */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }
        ::-webkit-scrollbar-track {
            background: #1E293B;
            border-radius: 3px;
        }
        ::-webkit-scrollbar-thumb {
            background: #3B82F6;
            border-radius: 3px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #2563EB;
        }

        .glass-card {
            background: rgba(30, 41, 59, 0.7);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.2);
        }

        .stream-container {
            position: relative;
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
            aspect-ratio: 16/9;
            overflow: hidden;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .stream-container img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .stream-container.fullscreen {
            width: 100vw !important;
            height: 100vh !important;
            max-width: none !important;
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            z-index: 9999 !important;
            margin: 0 !important;
            border-radius: 0 !important;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #000;
        }

        .stream-container.fullscreen img {
            min-width: 100%;
            min-height: 100%;
            max-width: none;
            max-height: none;
            object-fit: contain;
            transform: scale(1.001);
        }

        .stream-container .cursor-overlay {
            position: absolute;
            width: 11px;
            height: 16px;
            background: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M0 0v14l3.5-3L6 16.2l1.9-1-2.7-4.9 4.8-.5z' style='fill:%23fff'/%3E%3C/svg%3E") no-repeat;
            background-size: contain;
            pointer-events: none;
            z-index: 9998;
        }

        .control-button {
            transition: all 0.2s ease;
            position: relative;
            margin: 0.5rem 0 0.5rem 0;
            overflow: hidden;
            white-space: nowrap;
            font-size: 14px;
        }

        .control-button::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(rgba(255,255,255,0.1), rgba(255,255,255,0));
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .control-button:hover::after {
            opacity: 1;
        }

        .control-button:active {
            transform: scale(0.97);
        }

        @media (max-width: 640px) {
            .control-button {
                padding: 0.5rem !important;
                font-size: 12px;
            }
            
            .control-button span {
                display: none;
            }

        }

        #shellOutput {
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
        }

        .shortcut {
            transition: all 0.2s ease;
            min-width: 80px;
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid rgba(59, 130, 246, 0.2);
        }

        .shortcut:hover {
            background: rgba(59, 130, 246, 0.2);
            border-color: rgba(59, 130, 246, 0.3);
        }

        .shortcut:active {
            transform: scale(0.95);
            background: rgba(59, 130, 246, 0.3);
        }

        .accordion-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .accordion-content.active {
            max-height: 1000px;
        }

        input[type="range"]::-webkit-slider-runnable-track {
            background: rgba(30, 41, 59, 0.8);
        }

        input[type="range"]::-moz-range-track {
            background: rgba(30, 41, 59, 0.8);
        }

        /* Custom input styling */
        input[type="text"],
        input[type="number"],
        textarea {
            background: rgba(30, 41, 59, 0.8);
            border: 1px solid rgba(59, 130, 246, 0.2);
            transition: all 0.2s ease;
        }

        input[type="text"]:focus,
        input[type="number"]:focus,
        textarea:focus {
            border-color: #3B82F6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }

        /* Custom checkbox styling */
        input[type="checkbox"] {
            width: 18px;
            height: 18px;
            border-radius: 4px;
            border: 2px solid rgba(59, 130, 246, 0.4);
            appearance: none;
            -webkit-appearance: none;
            outline: none;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        input[type="checkbox"]:checked {
            background-color: #3B82F6;
            border-color: #3B82F6;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='white' width='18px' height='18px'%3E%3Cpath d='M0 0h24v24H0z' fill='none'/%3E%3Cpath d='M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z'/%3E%3C/svg%3E");
            background-size: 12px;
            background-position: center;
            background-repeat: no-repeat;
        }

        .connection-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            color: white;
            font-size: 1.2rem;
        }

        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 4px solid #3B82F6;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin-bottom: 1rem;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .animate-pulse-custom::before {
          content: '';
          width: 8px;
          height: 8px;
          background: #34D399;
          border-radius: 50%;
          display: inline-block;
          animation: pulse 2s infinite;
        }

        .command-history {
            font-family: 'Fira Code', monospace;
            line-height: 1.6;
        }
    </style>
</head>
<body class="text-gray-100 min-h-screen p-4 md:p-8">
    <div class="max-w-7xl mx-auto">
        <div id="connectionOverlay" class="connection-overlay">
            <div class="spinner"></div>
            <p id="connectionMessage">Connecting...</p>
        </div>
        <div class="relative px-4 pt-16 sm:pt-4">
            <div class="absolute top-4 right-4 z-10">
                <button id="logoutButton" class="hidden control-button bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded-lg">
                    Logout
                </button>
            </div>
            <header class="text-center mb-12 relative">
                <h1 class="text-3xl sm:text-4xl md:text-5xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-blue-600 px-12">
                    Remote Control Panel
                </h1>
                <p class="text-blue-300 mt-2">Secure Remote Access Interface</p>
            </header>
        </div>
        <div id="activeWindow" class="text-center mb-4 text-gray-300"></div>
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
            <!-- Left Column -->
            <div class="space-y-8">
                <!-- Stream Section -->
                <section id="streamSection" class="hidden glass-card rounded-xl p-4 sm:p-6">
                    <!-- Header with title and controls -->
                    <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4 mb-6">
                        <div class="flex items-center gap-3">
                            <h2 class="text-2xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-blue-600">Screen Stream</h2>
                            <span id="streamStatus" class="hidden items-center gap-2 px-3 py-1 text-sm font-medium rounded-full bg-gradient-to-r from-emerald-600 to-emerald-700 text-white shadow-sm">
                                <span class="h-2 w-2 rounded-full bg-emerald-400 animate-pulse"></span>
                                <span id="currentFPS">0</span> FPS
                            </span>
                        </div>
                        <div class="flex flex-wrap gap-2">
                            <div class="inline-flex rounded-lg overflow-hidden shadow-sm">
                                <button id="startStream" class="inline-flex items-center justify-center w-10 h-10 bg-emerald-600 hover:bg-emerald-700 text-white transition-colors" title="Start Stream">
                                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z"/><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/></svg>
                                </button>
                                <button id="stopStream" class="inline-flex items-center justify-center w-10 h-10 bg-red-600 hover:bg-red-700 text-white transition-colors" title="Stop Stream">
                                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 10a1 1 0 011-1h4a1 1 0 011 1v4a1 1 0 01-1 1h-4a1 1 0 01-1-1v-4z"/></svg>
                                </button>
                            </div>
                            <div class="inline-flex rounded-lg overflow-hidden shadow-sm">
                                <button id="screenshot" class="inline-flex items-center justify-center w-10 h-10 bg-blue-600 hover:bg-blue-700 text-white transition-colors" title="Take Screenshot">
                                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 9a2 2 0 012-2h.93a2 2 0 001.664-.89l.812-1.22A2 2 0 0110.07 4h3.86a2 2 0 011.664.89l.812 1.22A2 2 0 0018.07 7H19a2 2 0 012 2v9a2 2 0 01-2 2H5a2 2 0 01-2-2V9z"/><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 13a3 3 0 11-6 0 3 3 0 016 0z"/></svg>
                                </button>
                                <button id="fullscreenBtn" class="inline-flex items-center justify-center w-10 h-10 bg-indigo-600 hover:bg-indigo-700 text-white transition-colors" title="Toggle Fullscreen">
                                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4"/></svg>
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- Stream container with collapsed state -->
                    <div id="streamContainer" class="stream-container mb-6 transition-all duration-300 ease-in-out" style="height: 0;">
                        <img id="streamView" src="" alt="Screen Stream" class="w-full h-full object-cover">
                        <div id="cursorOverlay" class="cursor-overlay"></div>
                    </div>

                    <!-- Stream settings -->
                    <div class="space-y-6 bg-black/10 rounded-lg p-4">
                        <div class="space-y-6">
                            <div class="flex flex-col sm:flex-row sm:items-center gap-2 sm:gap-4">
                                <label class="text-sm font-medium sm:w-24">Quality</label>
                                <div class="flex-1">
                                    <input type="range" id="streamQuality" min="1" max="100" value="100" class="w-full" oninput="updateStreamSettings()">
                                    <div class="flex justify-end mt-1">
                                        <span id="qualityValue" class="text-sm font-medium">100%</span>
                                    </div>
                                </div>
                            </div>

                            <div class="flex flex-col sm:flex-row sm:items-center gap-2 sm:gap-4">
                                <label class="text-sm font-medium sm:w-24">Resolution</label>
                                <div class="flex-1">
                                    <input type="range" id="streamResolution" min="1" max="100" value="100" class="w-full" oninput="updateStreamSettings()">
                                    <div class="flex justify-end mt-1">
                                        <span id="resolutionValue" class="text-sm font-medium">100%</span>
                                    </div>
                                </div>
                            </div>

                            <div class="flex flex-col sm:flex-row sm:items-center gap-2 sm:gap-4">
                                <label class="text-sm font-medium sm:w-24">Target FPS</label>
                                <div class="flex-1">
                                    <div class="flex flex-col gap-2">
                                        <div class="flex flex-col sm:flex-row gap-2">
                                            <div class="flex-1">
                                                <input type="range" id="streamFPS" min="1" max="120" value="60" 
                                                       class="w-full" oninput="updateStreamSettings()">
                                            </div>
                                            <button onclick="setAutoFPS()" 
                                                    class="w-full sm:w-auto px-3 py-1.5 rounded-lg bg-blue-600 hover:bg-blue-700 text-white transition-colors text-sm">
                                                Auto
                                            </button>
                                        </div>
                                        <div class="flex justify-end">
                                            <span id="fpsValue" class="text-sm font-medium">60 FPS</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </section>

                <!-- Audio Controls -->
                <section id="audioSection" class="hidden glass-card rounded-xl p-6">
                    <h2 class="text-2xl font-bold mb-6 bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-blue-600">Audio Controls</h2>
                    <div class="space-y-4">
                        <!-- Server Audio -->
                        <div>
                            <h3 class="font-medium mb-2 flex items-center gap-2">Server Audio</h3>
                            <div class="flex flex-col gap-3">
                                <div class="flex flex-wrap items-center gap-3">
                                    <select id="audioSourceSelect" class="px-3 py-2 rounded-lg bg-gray-700 text-white min-w-[120px]">
                                        <option value="mic">Microphone</option>
                                        <option value="system">System Audio</option>
                                    </select>
                                    <div class="flex flex-wrap gap-3">
                                        <input type="number" id="serverAudioRate" placeholder="Rate (Hz)" value="48000" class="px-3 py-2 rounded-lg bg-gray-700 text-white w-[120px]">
                                        <input type="number" id="serverAudioChunk" placeholder="Chunk" value="4096" class="px-3 py-2 rounded-lg bg-gray-700 text-white w-[120px]">
                                    </div>
                                </div>
                                <div class="flex flex-wrap items-center gap-2">
                                    <button id="startServerAudio" class="control-button bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-lg flex items-center gap-2">Start</button>
                                    <button id="stopServerAudio" class="control-button bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded-lg flex items-center gap-2">Stop</button>
                                </div>
                            </div>
                        </div>

                        <!-- Client Audio -->
                        <div>
                            <h3 class="font-medium mb-2 flex items-center gap-2">Client Audio</h3>
                            <div class="flex flex-col gap-3">
                                <div class="flex flex-wrap items-center gap-3">
                                    <input type="number" id="clientAudioRate" placeholder="Rate (Hz)" value="48000" class="px-3 py-2 rounded-lg bg-gray-700 text-white w-[120px]">
                                    <input type="number" id="clientAudioChunk" placeholder="Chunk" value="512" class="px-3 py-2 rounded-lg bg-gray-700 text-white w-[120px]">
                                </div>
                                <div class="flex flex-wrap items-center gap-2">
                                    <button id="startClientAudio" class="control-button bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-lg flex items-center gap-2">Start</button>
                                    <button id="stopClientAudio" class="control-button bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded-lg flex items-center gap-2">Stop</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </section>

                <!-- Shell Commands -->
                <section id="shellSection" class="hidden glass-card rounded-xl p-4 sm:p-6">
                    <h2 class="text-2xl font-bold mb-6 bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-blue-600">Shell Commands</h2>
                    <div class="flex flex-col sm:flex-row gap-3 mb-4">
                        <input type="text" id="shellCommand" class="flex-1 px-4 py-3 rounded-lg" placeholder="Enter shell command...">
                        <button id="executeCommand" class="control-button bg-blue-600 hover:bg-blue-700 text-white px-4 py-3 rounded-lg flex items-center justify-center gap-2 whitespace-nowrap">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"/>
                            </svg>
                            <span>Execute</span>
                        </button>
                    </div>
                    <div id="shellOutput" class="command-history bg-gray-900/50 rounded-lg p-4 h-64 overflow-y-auto text-green-400 font-mono text-sm border border-gray-700"></div>
                </section>
            </div>

            <!-- Right Column -->
            <div class="space-y-8">
                <!-- Keyboard Controls -->
                <section id="keyboardSection" class="hidden glass-card rounded-xl p-6">
                    <h2 class="text-2xl font-bold mb-6 bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-blue-600">Keyboard Controls</h2>
                    
                    <div class="space-y-4">
                        <!-- Common Actions -->
                        <div class="accordion">
                            <button class="w-full flex justify-between items-center p-4 bg-blue-500/10 rounded-lg hover:bg-blue-500/20 transition-colors">
                                <span class="font-medium flex items-center gap-2">
                                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"/>
                                    </svg>
                                    Common Actions
                                </span>
                                <svg class="w-5 h-5 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"/>
                                </svg>
                            </button>
                            <div class="accordion-content">
                                <div class="grid grid-cols-2 sm:grid-cols-4 gap-3 p-4">
                                    <button class="shortcut px-4 py-3 rounded-lg text-blue-400 hover:text-blue-300" data-key="copy">Copy</button>
                                    <button class="shortcut px-4 py-3 rounded-lg text-blue-400 hover:text-blue-300" data-key="paste">Paste</button>
                                    <button class="shortcut px-4 py-3 rounded-lg text-blue-400 hover:text-blue-300" data-key="cut">Cut</button>
                                    <button class="shortcut px-4 py-3 rounded-lg text-blue-400 hover:text-blue-300" data-key="undo">Undo</button>
                                    <button class="shortcut px-4 py-3 rounded-lg text-blue-400 hover:text-blue-300" data-key="space">Space</button>
                                </div>
                            </div>
                        </div> 

                        <!-- Navigation -->
                        <div class="accordion">
                            <button class="w-full flex justify-between items-center p-4 bg-blue-500/10 rounded-lg hover:bg-blue-500/20 transition-colors">
                                <span class="font-medium flex items-center gap-2">
                                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8h16M4 16h16"/>
                                    </svg>
                                    Navigation
                                </span>
                                <svg class="w-5 h-5 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"/>
                                </svg>
                            </button>
                            <div class="accordion-content">
                                <div class="p-4 space-y-6">
                                    <!-- Arrow keys -->
                                    <div class="flex flex-col items-center gap-2">
                                        <button class="shortcut w-16 h-16 rounded-lg flex items-center justify-center text-blue-400 hover:text-blue-300" data-key="up">↑</button>
                                        <div class="flex gap-2">
                                            <button class="shortcut w-16 h-16 rounded-lg flex items-center justify-center text-blue-400 hover:text-blue-300" data-key="left">←</button>
                                            <button class="shortcut w-16 h-16 rounded-lg flex items-center justify-center text-blue-400 hover:text-blue-300" data-key="down">↓</button>
                                            <button class="shortcut w-16 h-16 rounded-lg flex items-center justify-center text-blue-400 hover:text-blue-300" data-key="right">→</button>
                                        </div>
                                    </div>
                                    <!-- Other navigation keys -->
                                    <div class="grid grid-cols-2 sm:grid-cols-4 gap-3">
                                        <button class="shortcut px-4 py-3 rounded-lg text-blue-400 hover:text-blue-300" data-key="home">Home</button>
                                        <button class="shortcut px-4 py-3 rounded-lg text-blue-400 hover:text-blue-300" data-key="end">End</button>
                                        <button class="shortcut px-4 py-3 rounded-lg text-blue-400 hover:text-blue-300" data-key="pgup">PgUp</button>
                                        <button class="shortcut px-4 py-3 rounded-lg text-blue-400 hover:text-blue-300" data-key="pgdown">PgDn</button>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- System Keys -->
                        <div class="accordion">
                            <button class="w-full flex justify-between items-center p-4 bg-blue-500/10 rounded-lg hover:bg-blue-500/20 transition-colors">
                                <span class="font-medium flex items-center gap-2">
                                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                                    </svg>
                                    System Keys
                                </span>
                                <svg class="w-5 h-5 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                                </svg>
                            </button>
                            <div class="accordion-content">
                                <div class="grid grid-cols-2 sm:grid-cols-4 gap-3 p-4">
                                    <button class="shortcut px-4 py-3 rounded-lg text-blue-400 hover:text-blue-300" data-key="win">Win</button>
                                    <button class="shortcut px-4 py-3 rounded-lg text-blue-400 hover:text-blue-300" data-key="alt-tab">Alt+Tab</button>
                                    <button class="shortcut px-4 py-3 rounded-lg text-blue-400 hover:text-blue-300" data-key="esc">Esc</button>
                                </div>
                            </div>
                        </div>

                        <!-- Custom Shortcut -->
                        <div class="mt-6 p-6 bg-blue-500/10 rounded-lg">
                            <h3 class="text-lg font-medium mb-4 flex items-center gap-2">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6V4m0 2a2 2 0 100 4m0-4a2 2 0 110 4m-6 8a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4m6 6v10m6-2a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4"/>
                                </svg>
                                Custom Shortcut
                            </h3>
                            <div class="flex flex-wrap gap-4 mb-4">
                                <label class="inline-flex items-center gap-2">
                                    <input type="checkbox" class="modifier-key" value="ctrl">
                                    <span>Ctrl</span>
                                </label>
                                <label class="inline-flex items-center gap-2">
                                    <input type="checkbox" class="modifier-key" value="win">
                                    <span>Win</span>
                                </label>
                                <label class="inline-flex items-center gap-2">
                                    <input type="checkbox" class="modifier-key" value="alt">
                                    <span>Alt</span>
                                </label>
                                <label class="inline-flex items-center gap-2">
                                    <input type="checkbox" class="modifier-key" value="shift">
                                    <span>Shift</span>
                                </label>
                            </div>
                            <div class="flex flex-col sm:flex-row gap-3">
                                <input type="text" id="customKey" class="flex-1 px-4 py-3 rounded-lg border border-gray-300 focus:outline-none" placeholder="Key (e.g. escape)">
                                <button id="sendCustomShortcut" class="control-button bg-purple-600 hover:bg-purple-700 text-white px-4 py-3 rounded-lg flex items-center justify-center gap-2 whitespace-nowrap">
                                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 12h14M12 5l7 7-7 7"/>
                                    </svg>
                                    <span>Send</span>
                                </button>
                            </div>
                        </div>

                        <!-- Text Input -->
                        <div class="mt-6">
                            <textarea id="textInput" class="w-full px-4 py-3 rounded-lg resize-none h-24" placeholder="Type text to send..."></textarea>
                            <button id="sendText" class="control-button mt-3 bg-blue-600 hover:bg-blue-700 text-white px-6 py-3 rounded-lg w-full">Send Text</button>
                        </div>
                    </div>
                </section>

                <!-- File Management Section -->
                <section id="fileSection" class="hidden glass-card rounded-xl p-6">
                    <!-- Title -->
                    <h2 class="text-2xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-blue-600 mb-6">File Management</h2>

                    <!-- Drop Zone -->
                    <div id="dropZone" class="flex justify-center items-center border-2 border-dashed border-blue-500/50 rounded-xl p-8 mb-6 transition-all hover:border-blue-500 hover:bg-blue-500/5">
                        <div class="text-center">
                            <svg class="w-10 h-10 mx-auto mb-2 text-blue-500/70" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"/>
                            </svg>
                            <p class="text-gray-400">Drag and drop files here to upload</p>
                        </div>
                    </div>

                    <!-- File Browser -->
                    <div class="space-y-6">
                        <div>
                            <h3 class="font-medium mb-3 flex items-center gap-2 text-gray-200">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z"/>
                                </svg>
                                File Browser
                            </h3>
                            <div id="currentPath" class="text-sm text-gray-400 mb-2"></div>
                            <div class="overflow-auto max-h-96">
                                <table id="fileTable" class="min-w-full table-fixed">
                                    <thead class="bg-gray-800/50 text-gray-300 sticky top-0">
                                        <tr>
                                            <th class="w-2/4 px-4 py-2 text-left">Name</th>
                                            <th class="w-1/4 px-4 py-2 text-left">Size</th>
                                            <th class="w-1/4 px-4 py-2 text-left">Last Modified</th>
                                        </tr>
                                    </thead>
                                    <tbody id="fileList" class="bg-black/20 divide-y divide-gray-800/50">
                                        <!-- File items will be inserted here -->
                                    </tbody>
                                </table>
                            </div>
                        </div>

                        <!-- File Operations -->
                        <div id="fileOperations" class="hidden">
                            <div class="flex flex-wrap gap-2">
                                <button id="downloadFile" class="inline-flex items-center gap-1.5 px-4 py-2 rounded-lg bg-blue-600 hover:bg-blue-700 text-white transition-colors disabled:bg-blue-900/70 disabled:cursor-not-allowed">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4 4l-4 4m0 0l-4-4m4 4V4"/>
                                    </svg>
                                    Download
                                </button>
                                <button id="deleteItem" class="inline-flex items-center gap-1.5 px-4 py-2 rounded-lg bg-red-600 hover:bg-red-700 text-white transition-colors disabled:bg-red-900/70 disabled:cursor-not-allowed">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                    </svg>
                                    Delete
                                </button>
                                <div class="w-full sm:w-auto flex flex-col sm:flex-row gap-2">
                                    <input type="text" id="renameInput" placeholder="New name" class="flex-grow min-w-[200px] px-3 py-2 rounded-lg bg-white/5 border border-gray-700 focus:border-blue-500 transition-colors disabled:bg-white/5 disabled:cursor-not-allowed">
                                    <button id="renameItem" class="inline-flex items-center justify-center gap-1.5 px-4 py-2 rounded-lg bg-amber-600 hover:bg-amber-700 text-white transition-colors disabled:bg-amber-900/70 disabled:cursor-not-allowed">
                                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 10h10a8 8 0 018 8v2M3 10l6 6m-6-6l6-6"/>
                                        </svg>
                                        Rename
                                    </button>
                                </div>
                            </div>
                        </div>

                        <!-- Create Folder -->
                        <div class="flex flex-wrap gap-2">
                            <input type="text" id="newFolderName" placeholder="New folder name" class="w-full sm:w-auto sm:flex-1 px-3 py-2 rounded-lg bg-white/5 border border-gray-700 focus:border-blue-500 transition-colors min-w-[200px]">
                            <button id="createFolder" class="w-full sm:w-auto inline-flex items-center justify-center gap-1.5 px-4 py-2 rounded-lg bg-emerald-600 hover:bg-emerald-700 text-white transition-colors whitespace-nowrap">
                                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"/>
                                </svg>
                                Create Folder
                            </button>
                        </div>

                        <!-- File Upload -->
                        <div>
                            <h3 class="font-medium mb-3 flex items-center gap-2 text-gray-200">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"/>
                                </svg>
                                Upload File
                            </h3>
                            <div class="flex flex-wrap items-center gap-2">
                                <input type="file" id="fileUpload" class="hidden" name="files" multiple onchange="updateSelectedFileName(this)">
                                <label for="fileUpload" class="inline-flex items-center gap-1.5 px-4 py-2 rounded-lg bg-blue-600 hover:bg-blue-700 text-white transition-colors cursor-pointer">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"/>
                                    </svg>
                                    Choose File
                                </label>
                                <span id="selectedFileName" class="text-gray-400">No file chosen</span>
                                <button id="uploadFile" class="inline-flex items-center gap-1.5 px-4 py-2 rounded-lg bg-emerald-600 hover:bg-emerald-700 text-white transition-colors">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"/>
                                    </svg>
                                    Upload
                                </button>
                            </div>
                        </div>
                    </div>
                </section>

                <!-- System Info -->
                <div id="systemSection" class="hidden glass-card rounded-xl p-6">
                    <h2 class="text-2xl font-bold mb-6 bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-blue-600">System Information</h2>
                    <div id="systemInfo" class="bg-gray-900/50 p-4 rounded-lg space-y-2 whitespace-pre-wrap break-words max-w-full"></div>
                </div>
            </div>
        </div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.8.1/socket.io.min.js"></script>
    <script>
        let socket;
        let reconnectionAttempts = 0;
        const MAX_RECONNECTION_ATTEMPTS = 5;
        let reconnectionDelay = 1000;

        const connectionOverlay = document.getElementById('connectionOverlay');
        const connectionMessage = document.getElementById('connectionMessage');
        const allInteractiveElements = document.querySelectorAll('button, input, select, textarea');

        function disableInteractiveElements() {
            allInteractiveElements.forEach(element => {
                element.disabled = true;
            });
        }

        function enableInteractiveElements() {
            allInteractiveElements.forEach(element => {
                element.disabled = false;
            });
        }

        function showConnectionOverlay(message) {
            connectionMessage.textContent = message;
            connectionOverlay.classList.remove('hidden');
            disableInteractiveElements();
        }

        function hideConnectionOverlay() {
            connectionOverlay.classList.add('hidden');
            enableInteractiveElements();
        }

        function attemptReconnection() {
            if (reconnectionAttempts < MAX_RECONNECTION_ATTEMPTS) {
                reconnectionAttempts++;
                showConnectionOverlay(`Reconnecting... Attempt ${reconnectionAttempts}`);
                setTimeout(() => {
                    console.log('Attempting to reconnect...');
                    socket.connect();
                }, reconnectionDelay);
                reconnectionDelay *= 2;
            } else {
                showConnectionOverlay('Connection failed after multiple attempts.');
            }
        }

        function initializeSocketIO() {
            showConnectionOverlay('Connecting...');
            
            socket = io({
                reconnection: false
            });

            socket.on('connect', () => {
                console.log('Socket connected!');
                hideConnectionOverlay();
                reconnectionAttempts = 0;
                reconnectionDelay = 1000;
            });

            socket.on('disconnect', (reason) => {
                console.log('Socket disconnected:', reason);
                if (reason !== 'io client disconnect') {
                    attemptReconnection();
                }
            });

            socket.on('connect_error', (error) => {
                console.error('Socket connection error:', error);
                attemptReconnection();
            });
        }

        initializeSocketIO();

        let isAuthenticated = false;

        function updateUIBasedOnAuthentication() {
            const sections = ['streamSection', 'audioSection', 'shellSection', 'keyboardSection', 'fileSection', 'systemSection'];
            sections.forEach(sectionId => {
                const section = document.getElementById(sectionId);
                if (isAuthenticated) {
                    section.classList.remove('hidden');
                } else {
                    section.classList.add('hidden');
                }
            });

            const logoutButton = document.getElementById('logoutButton');
            if (isAuthenticated) {
                logoutButton.classList.remove('hidden');
            } else {
                logoutButton.classList.add('hidden');
            }
        }

        document.getElementById('logoutButton').addEventListener('click', async (e) => {
            e.preventDefault();
            const response = await fetch('/logout');
            if (response.ok) {
                isAuthenticated = false;
                updateUIBasedOnAuthentication();
                window.location.href = '/login';
            }
        });

        socket.on('auth_status', (data) => {
            if (isAuthenticated !== data.authenticated) {
                isAuthenticated = data.authenticated;
                updateUIBasedOnAuthentication();
            }
        });

        class AudioManager {
            constructor(socket) {
                this.socket = socket;
                this.audioContext = null;
                this.currentStream = null;
                this.workletNode = null;
                this.audioQueue = [];
                this.isProcessingAudio = false;
                this.currentSettings = {
                    server: { rate: 48000, chunk: 4096 },
                    client: { rate: 48000, chunk: 512 }
                };
                this.streamActive = {
                    server: false,
                    client: false
                };

                this.handleServerAudioData = this.handleServerAudioData.bind(this);
                this.initializeEventListeners();
            }
            
            validateSampleRate(rate) {
                const MIN_RATE = 3000;
                const MAX_RATE = 768000;
                if (rate < MIN_RATE || rate > MAX_RATE) {
                    alert(`Sample rate must be between ${MIN_RATE} and ${MAX_RATE}`);
                    return false;
                }
                return true;
            }
            
            async ensureAudioContext(sampleRate) {
                if (!this.validateSampleRate(sampleRate)) {
                    return false;
                }
                
                if (this.audioContext) {
                    if (this.audioContext.sampleRate !== sampleRate) {
                        await this.audioContext.close();
                        this.audioContext = null;
                    }
                }
                
                if (!this.audioContext) {
                    this.audioContext = new AudioContext({ sampleRate });
                }
                
                if (this.audioContext.state === 'suspended') {
                    await this.audioContext.resume();
                }
                
                return true;
            }

            async initializeAudioWorklet() {
                try {
                    // Remove any existing worklet before adding new one
                    if (this.workletNode) {
                        this.cleanupWorklet();
                    }
                    await this.audioContext.audioWorklet.addModule('/static/audio-worklet-processor.js');
                } catch (e) {
                    console.error('Failed to add audio worklet module:', e);
                    throw e;
                }
            }

            async getMicrophoneStream(settings) {
                try {
                    if (this.currentStream) {
                        this.currentStream.getTracks().forEach(track => track.stop());
                        this.currentStream = null;
                    }
                    
                    return await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            sampleRate: settings.rate,
                            channelCount: 1,
                            echoCancellation: true,
                            noiseSuppression: true
                        }
                    });
                } catch (error) {
                    console.error('Error accessing microphone:', error);
                    return null;
                }
            }

            async updateSettings(settings) {
                const type = settings.type;
                const needsReset = JSON.stringify(this.currentSettings[type]) !== JSON.stringify(settings);
                
                if (needsReset) {
                    // Stop current stream before applying new settings
                    await this.stopAudioStream(type, true);
                    this.currentSettings[type] = { ...settings };
                }

                await fetch('/api/stream/settings', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ audio_settings: settings })
                });
                
                return needsReset;
            }

            async startAudioStream(type, settings = {}) {
                try {
                    // Check if stream is already active and settings haven't changed
                    if (this.streamActive[type] && !await this.updateSettings({ ...settings, type })) {
                        console.log(`${type} audio stream is already active`);
                        return;
                    }

                    // Stop any existing stream first
                    await this.stopAudioStream(type, true);

                    await this.ensureAudioContext(settings.rate || this.currentSettings[type].rate);

                    if (type === 'client') {
                        this.currentStream = await this.getMicrophoneStream(settings);
                        if (!this.currentStream) {
                            throw new Error('Failed to access microphone');
                        }

                        await this.initializeAudioWorklet();
                        this.setupWorkletNode(settings.chunk || this.currentSettings.client.chunk);

                        const source = this.audioContext.createMediaStreamSource(this.currentStream);
                        source.connect(this.workletNode);
                    }

                    // Remove any existing server_audio_data listeners before adding new one
                    if (type === 'server') {
                        this.socket.off('server_audio_data', this.handleServerAudioData);
                        this.socket.on('server_audio_data', this.handleServerAudioData);
                    }

                    this.socket.emit(`start_${type}_audio`, settings);
                    this.streamActive[type] = true;

                } catch (error) {
                    console.error(`Error starting ${type} audio:`, error);
                    await this.stopAudioStream(type);
                    throw error;
                }
            }

            setupWorkletNode(bufferSize) {
                this.workletNode = new AudioWorkletNode(this.audioContext, 'client-audio-processor', {
                    processorOptions: { bufferSize }
                });

                this.workletNode.port.onmessage = (event) => {
                    if (event.data.type === 'pcmData') {
                        this.audioQueue.push(event.data.pcmData);
                        if (!this.isProcessingAudio) {
                            this.processAudioQueue();
                        }
                    }
                };
            }

            async processAudioQueue() {
                if (this.audioQueue.length === 0) {
                    this.isProcessingAudio = false;
                    return;
                }

                this.isProcessingAudio = true;
                const audioData = this.audioQueue.shift();

                this.socket.emit('client_audio_data', audioData, () => {
                    this.processAudioQueue();
                });
            }

            handleServerAudioData(data) {
                const uint8Array = new Uint8Array(data);
                if (uint8Array.length === 0) return;

                const bufferLength = uint8Array.length - (uint8Array.length % 2);
                const int16Array = new Int16Array(uint8Array.buffer, 0, bufferLength / 2);

                const audioBuffer = this.audioContext.createBuffer(1, int16Array.length, this.audioContext.sampleRate);
                const audioData = audioBuffer.getChannelData(0);

                for (let i = 0; i < int16Array.length; i++) {
                    audioData[i] = int16Array[i] / 32768.0;
                }

                const source = this.audioContext.createBufferSource();
                source.buffer = audioBuffer;
                source.connect(this.audioContext.destination);
                source.start();
                source.onended = () => source.disconnect();
            }

            async stopAudioStream(type, isResetting = false) {
                if (!this.streamActive[type] && !isResetting) {
                    return;
                }

                this.socket.emit(`stop_${type}_audio`);
                
                if (type === 'client') {
                    this.cleanupWorklet();
                } else if (type === 'server') {
                    this.socket.off('server_audio_data', this.handleServerAudioData);
                }

                // Only close AudioContext if we're not resetting
                if (!isResetting && this.audioContext) {
                    await this.audioContext.close();
                    this.audioContext = null;
                }

                this.streamActive[type] = false;
            }

            cleanupWorklet() {
                if (this.currentStream) {
                    this.currentStream.getTracks().forEach(track => track.stop());
                    this.currentStream = null;
                }
                if (this.workletNode) {
                    this.workletNode.disconnect();
                    this.workletNode.port.close();
                    this.workletNode = null;
                }
                this.audioQueue = [];
                this.isProcessingAudio = false;
            }

            cleanup() {
                this.cleanupWorklet();
            }

            initializeEventListeners() {
                // Server Audio Controls
                document.getElementById('startServerAudio').addEventListener('click', async () => {
                    const settings = {
                        source: document.getElementById('audioSourceSelect').value,
                        rate: parseInt(document.getElementById('serverAudioRate').value),
                        chunk: parseInt(document.getElementById('serverAudioChunk').value)
                    };
                    await this.startAudioStream('server', settings);
                });

                document.getElementById('stopServerAudio').addEventListener('click', () => {
                    this.stopAudioStream('server');
                });

                // Client Audio Controls
                document.getElementById('startClientAudio').addEventListener('click', async () => {
                    const settings = {
                        rate: parseInt(document.getElementById('clientAudioRate').value),
                        chunk: parseInt(document.getElementById('clientAudioChunk').value)
                    };
                    await this.startAudioStream('client', settings);
                });

                document.getElementById('stopClientAudio').addEventListener('click', () => {
                    this.stopAudioStream('client');
                });
            }
        }

        const audioManager = new AudioManager(socket);

        // Generate a unique session ID
        const sessionId = Math.random().toString(36).substring(2);
        let streamActive = false;
        let eventSource = null;
        let nativeWidth, nativeHeight;
        let fpsHistory = [];
        const FPS_HISTORY_SIZE = 30;

        // Utility function for API calls
        async function apiCall(endpoint, method = 'GET', data = null) {
            const options = {
                method,
                headers: {}
            };
            if (data) {
                options.headers['Content-Type'] = 'application/json';
                options.body = JSON.stringify(data);
            }
            const response = await fetch(endpoint, options);
            return response.json();
        }

        // Stream controls
        const streamUI = {
            container: document.getElementById('streamContainer'),
            status: document.getElementById('streamStatus'),
            view: document.getElementById('streamView'),
            fpsCounter: document.getElementById('currentFPS'),
            activeWindowText: document.getElementById('activeWindow'),
            cursorOverlay: document.getElementById('cursorOverlay'),

            show() {
                this.container.style.height = 'auto';
                this.status.classList.remove('hidden');
                this.status.classList.add('inline-flex');
            },

            hide() {
                this.container.style.height = '0';
                this.status.classList.remove('inline-flex');
                this.status.classList.add('hidden');
            },

            updateStream(data) {
                this.view.src = `data:image/jpeg;base64,${data.image}`;
                this.fpsCounter.textContent = data.fps;
                this.activeWindowText.textContent = data.active_window ? `Active Window: ${data.active_window}` : '';
            },

            clear() {
                this.view.src = '';
                this.fpsCounter.textContent = '0';
                this.cursorOverlay.style.display = 'none';
            }
        };

        document.getElementById('startStream').addEventListener('click', () => {
            if (!streamActive) {
                streamActive = true;
                streamUI.show();

                eventSource = new EventSource(`/api/stream?sid=${sessionId}`);
                eventSource.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    streamUI.updateStream(data);
                };
            }
        });

        document.getElementById('stopStream').addEventListener('click', async () => {
            if (streamActive) {
                streamActive = false;
                streamUI.hide();

                if (eventSource) {
                    eventSource.close();
                    eventSource = null;
                }
                await apiCall('/api/stream/stop');
                streamUI.clear();
            }
        });

        document.getElementById('screenshot').addEventListener('click', async () => {
            streamUI.show();
            
            const response = await apiCall('/api/screenshot');
            if (response.status === 'success') {
                streamUI.view.src = `data:image/jpeg;base64,${response.image}`;
            }
        });

        // Keyboard shortcuts
        document.querySelectorAll('.shortcut').forEach(button => {
            button.addEventListener('click', async () => {
                await apiCall('/api/keyboard/shortcut', 'POST', {
                    shortcut: button.dataset.key
                });
            });
        });

        // Text input
        document.getElementById('sendText').addEventListener('click', async () => {
            const text = document.getElementById('textInput').value;
            if (text) {
                await apiCall('/api/keyboard/type', 'POST', { text });
                document.getElementById('textInput').value = '';
            }
        });

        // Shell commands
        document.getElementById('executeCommand').addEventListener('click', async () => {
            const command = document.getElementById('shellCommand').value;
            if (command) {
                const result = await apiCall('/api/shell', 'POST', { command });
                const output = document.getElementById('shellOutput');
                
                output.innerHTML = '';
                if (result.status === 'success') {
                    if (result.stdout) {
                        output.innerHTML += `STDOUT:\n${result.stdout}\n`;
                    }
                    if (result.stderr) {
                        output.innerHTML += `STDERR:\n${result.stderr}\n`;
                    }
                    output.innerHTML += `Exit Code: ${result.code}`;
                } else {
                    output.innerHTML = `Error: ${result.message}`;
                }
                
                output.scrollTop = output.scrollHeight;
                document.getElementById('shellCommand').value = '';
            }
        });

        // System information
        async function updateSystemInfo() {
            const info = await apiCall('/api/system');
            const systemInfoDiv = document.getElementById('systemInfo');
            
            const formattedInfo = [
                `Hostname: ${info.hostname}`,
                `Platform: ${info.platform_info || 'N/A'}`,
                `Architecture: ${info.machine}`,
                `Processor: ${info.processor}`,
                `Boot Time: ${info.boot_time || 'N/A'}`,
                `CPU Count: ${info.cpu_count || 'N/A'}`,
                `Total Memory: ${info.total_memory || 'N/A'}`,
                `Disk Total: ${info.disk_total || 'N/A'}`,
                `Disk Used: ${info.disk_used || 'N/A'}`,
                `Disk Free: ${info.disk_free || 'N/A'}`,
                `MAC Address: ${info.mac_address || 'N/A'}`,
                `Active Processes: ${info.active_processes || 'N/A'}`
            ].join('\n');
            
            systemInfoDiv.textContent = formattedInfo;
        }

        updateSystemInfo();

        // Keyboard event handling
        document.addEventListener('keydown', async (e) => {
            // Only handle keyboard shortcuts when text input is not focused
            if (document.activeElement.tagName !== 'TEXTAREA' && 
                document.activeElement.tagName !== 'INPUT') {
                
                const key = e.key.toLowerCase();
                if (['arrowup', 'arrowdown', 'arrowleft', 'arrowright'].includes(key)) {
                    e.preventDefault();
                    await apiCall('/api/keyboard/shortcut', 'POST', {
                        shortcut: key.replace('arrow', '')
                    });
                }
            }
        });

        // Handle Enter key in shell command input
        document.getElementById('shellCommand').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                document.getElementById('executeCommand').click();
            }
        });

        // Handle Enter key in text input
        document.getElementById('textInput').addEventListener('keypress', (e) => {
            if (e.ctrlKey && e.key === 'Enter') {
                document.getElementById('sendText').click();
            }
        });

        document.getElementById('sendCustomShortcut').addEventListener('click', async () => {
            const modifiers = Array.from(document.querySelectorAll('.modifier-key:checked'))
                .map(cb => cb.value);
            const key = document.getElementById('customKey').value.toLowerCase().trim();
            
            if (key) {
                await apiCall('/api/keyboard/shortcut', 'POST', {
                    shortcut: key,
                    modifiers: modifiers
                });
            }
        });

        document.querySelectorAll('.accordion > button').forEach(button => {
            button.addEventListener('click', () => {
                const content = button.nextElementSibling;
                const icon = button.querySelector('span + svg');
                
                content.classList.toggle('active');
                icon.style.transform = content.classList.contains('active') ? 'rotate(180deg)' : '';
                
                // Close other accordions
                document.querySelectorAll('.accordion-content').forEach(otherContent => {
                    if (otherContent !== content) {
                        otherContent.classList.remove('active');
                        const otherIcon = otherContent.previousElementSibling.querySelector('span + svg');
                        if (otherIcon) {
                            otherIcon.style.transform = '';
                        }
                    }
                });
            });
        });

        async function updateStreamSettings() {
            const quality = document.getElementById('streamQuality').value;
            document.getElementById('qualityValue').textContent = quality + '%';

            const resolutionPercentage = document.getElementById('streamResolution').value;
            const resolutionText = resolutionPercentage == 100 ?
                "100% (Native)" :
                `${resolutionPercentage}% (${Math.round(nativeWidth * resolutionPercentage / 100)} x ${Math.round(nativeHeight * resolutionPercentage / 100)})`;
            document.getElementById('resolutionValue').textContent = resolutionText;

            const fps = document.getElementById('streamFPS').value;
            document.getElementById('fpsValue').textContent = `${fps} FPS`;

            const response = await apiCall('/api/stream/settings', 'POST', {
                quality: parseInt(quality),
                resolution_percentage: parseInt(resolutionPercentage),
                target_fps: fps ? parseInt(fps) : null
            });

            updateSettingsDisplay(response);
        }

        function updateSettingsDisplay(settings) {
            nativeWidth = settings.native_width;
            nativeHeight = settings.native_height;

            const resolutionPercentage = settings.resolution_percentage;
            const resolutionText = resolutionPercentage == 100 ?
                "100% (Native)" :
                `${resolutionPercentage}% (${Math.round(nativeWidth * resolutionPercentage / 100)} x ${Math.round(nativeHeight * resolutionPercentage / 100)})`;
            document.getElementById('resolutionValue').textContent = resolutionText;

            const fpsValue = document.getElementById('fpsValue');
            fpsValue.textContent = settings.target_fps === null ?
                '(Unlimited FPS)' :
                `(Target: ${settings.target_fps} FPS)`;
        }

        function setAutoFPS() {
            document.getElementById('streamFPS').value = 60;
            document.getElementById('fpsValue').textContent = "Auto";
            updateStreamSettings();
        }

        // Get initial settings when page loads
        window.addEventListener('load', async () => {
            const response = await apiCall('/api/stream/settings', 'GET');
            updateSettingsDisplay(response);
            updateUIBasedOnAuthentication();
        });

        const fullscreenBtn = document.getElementById('fullscreenBtn');
        const streamContainer = document.querySelector('.stream-container');
        const streamView = document.getElementById('streamView');

        let isFullscreen = false;

        function handleFullscreen() {
            if (!isFullscreen) {
                if (streamContainer.requestFullscreen) {
                    streamContainer.requestFullscreen();
                } else if (streamContainer.mozRequestFullScreen) {
                    streamContainer.mozRequestFullScreen();
                } else if (streamContainer.webkitRequestFullscreen) {
                    streamContainer.webkitRequestFullscreen();
                } else if (streamContainer.msRequestFullscreen) {
                    streamContainer.msRequestFullscreen();
                }
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
            }
        }

        function adjustStreamSize() {
            if (isFullscreen) {
                streamContainer.classList.add('fullscreen');
                streamContainer.style.display = 'none';
                streamContainer.offsetHeight;
                streamContainer.style.display = 'flex';
            } else {
                streamContainer.classList.remove('fullscreen');
                streamView.style.width = '';
                streamView.style.height = '';
            }
        }

        function onFullscreenChange() {
            isFullscreen = !isFullscreen;
            if (isFullscreen) {
                streamView.classList.add('fullscreen');
            } else {
                streamView.classList.remove('fullscreen');
            }
            adjustStreamSize();
        }

        fullscreenBtn.addEventListener('click', handleFullscreen);

        document.addEventListener('fullscreenchange', onFullscreenChange);
        document.addEventListener('webkitfullscreenchange', onFullscreenChange);
        document.addEventListener('mozfullscreenchange', onFullscreenChange);
        document.addEventListener('MSFullscreenChange', onFullscreenChange);
        window.addEventListener('load', adjustStreamSize);
        window.addEventListener('resize', adjustStreamSize);

        let touchStarted = false;
        let isCtrlPressed = false;
        let initialTouchY = null;
        let isScrolling = false;
        let isDragging = false;

        document.addEventListener('keydown', (event) => {
            if (event.key === 'Control') {
                isCtrlPressed = true;
            }
        });

        document.addEventListener('keyup', (event) => {
            if (event.key === 'Control') {
                isCtrlPressed = false;
            }
        });

        // Handle case where user switches windows while holding Ctrl
        window.addEventListener('blur', () => {
            isCtrlPressed = false;
            isDragging = false;
        });

        // Prevent dragging
        streamView.addEventListener('dragstart', (event) => {
            event.preventDefault();
        });

        // Handle mouse wheel events
        streamView.addEventListener('wheel', (event) => {
            event.preventDefault();
            sendMouseEvent('scroll', event, { dx: 0, dy: -Math.sign(event.deltaY) });
        });

        // Touch event handlers
        streamView.addEventListener('touchstart', (event) => {
            event.preventDefault();
            
            if (event.touches.length === 2) {
                if (touchStarted) {
                    touchStarted = false;
                    const touch = event.touches[0];
                    sendMouseEvent('click', touch, { button: 'left', pressed: false });
                }
                isScrolling = true;
                initialTouchY = event.touches[1].clientY;
                return;
            }
            
            if (event.touches.length === 1 && !isScrolling) {
                touchStarted = true;
                const touch = event.touches[0];
                sendMouseEvent('click', touch, { button: 'left', pressed: true });
            }
        });

        streamView.addEventListener('touchmove', (event) => {
            event.preventDefault();
            
            if (event.touches.length === 2 && isScrolling && initialTouchY !== null) {
                const currentTouchY = event.touches[1].clientY;
                const deltaY = initialTouchY - currentTouchY;
                
                if (Math.abs(deltaY) > 5) {
                    sendMouseEvent('scroll', event.touches[0], { dx: 0, dy: -Math.sign(deltaY) });
                    initialTouchY = currentTouchY;
                }
                return;
            }
            
            if (event.touches.length === 1 && touchStarted && !isScrolling) {
                const touch = event.touches[0];
                sendMouseEvent('move', touch);
            }
        });

        streamView.addEventListener('touchend', (event) => {
            event.preventDefault();
            
            if (event.touches.length === 0) {
                isScrolling = false;
                initialTouchY = null;
            }
            
            if (touchStarted && event.touches.length === 0) {
                touchStarted = false;
                const lastTouch = event.changedTouches[0];
                sendMouseEvent('click', lastTouch, { button: 'left', pressed: false });
            }
        });

        streamView.addEventListener('touchcancel', (event) => {
            event.preventDefault();
            isScrolling = false;
            initialTouchY = null;
            
            if (touchStarted) {
                touchStarted = false;
                const lastTouch = event.changedTouches[0];
                sendMouseEvent('click', lastTouch, { button: 'left', pressed: false });
            }
        });

        // Mouse event handlers
        streamView.addEventListener('mousemove', (event) => {
            event.preventDefault();
            // Send move events if we're dragging or if Ctrl is pressed
            if (isDragging || isCtrlPressed) {
                sendMouseEvent('move', event);
            }
        });

        streamView.addEventListener('mousedown', (event) => {
            event.preventDefault();
            const button = event.button === 0 ? 'left' : event.button === 2 ? 'right' : 'middle';
            sendMouseEvent('click', event, { button, pressed: true });
            
            // Set dragging state on left click
            if (button === 'left') {
                isDragging = true;
            }
        });

        streamView.addEventListener('mouseup', (event) => {
            event.preventDefault();
            const button = event.button === 0 ? 'left' : event.button === 2 ? 'right' : 'middle';
            sendMouseEvent('click', event, { button, pressed: false });
            
            // Clear dragging state
            if (button === 'left') {
                isDragging = false;
            }
        });

        streamView.addEventListener('contextmenu', (event) => {
            event.preventDefault();
        });

        function calculateStreamDimensions() {
            const rect = streamView.getBoundingClientRect();
            const container = streamContainer.getBoundingClientRect();
            
            let streamWidth = rect.width;
            let streamHeight = rect.height;
            
            if (isFullscreen) {
                const containerAspect = container.width / container.height;
                const streamAspect = nativeWidth / nativeHeight;
                
                if (containerAspect > streamAspect) {
                    streamWidth = container.height * streamAspect;
                    streamHeight = container.height;
                } else {
                    streamWidth = container.width;
                    streamHeight = container.width / streamAspect;
                }
            }

            const offsetX = (container.width - streamWidth) / 2;
            const offsetY = (container.height - streamHeight) / 2;
            
            return {
                container,
                streamWidth,
                streamHeight,
                offsetX,
                offsetY,
                scaleX: nativeWidth / streamWidth,
                scaleY: nativeHeight / streamHeight
            };
        }

        function sendMouseEvent(type, event, options = {}) {
            if (!streamActive) return;
            
            // Process move events during drag or when Ctrl is pressed
            if (type === 'move' && !isCtrlPressed && !isDragging && !touchStarted) {
                return;
            }
            
            const clientX = event.touches ? event.clientX : event.clientX;
            const clientY = event.touches ? event.clientY : event.clientY;
            
            const dimensions = calculateStreamDimensions();
            const relativeX = clientX - dimensions.container.left - dimensions.offsetX;
            const relativeY = clientY - dimensions.container.top - dimensions.offsetY;
            
            const x = Math.max(0, Math.min(nativeWidth, relativeX * dimensions.scaleX));
            const y = Math.max(0, Math.min(nativeHeight, relativeY * dimensions.scaleY));
            
            const data = { type, x, y, ...options };
            socket.emit('mouse_event', data);
        }

        socket.on('mouse_position', (data) => {
            const dimensions = calculateStreamDimensions();
            
            // Calculate cursor position in client coordinates
            const adjustedX = (data.x / dimensions.scaleX) + dimensions.offsetX;
            const adjustedY = (data.y / dimensions.scaleY) + dimensions.offsetY;
            
            cursorOverlay.style.display = 'block';
            cursorOverlay.style.left = `${adjustedX}px`;
            cursorOverlay.style.top = `${adjustedY}px`;
            
            // Hide cursor when outside stream bounds
            if (
                adjustedX < dimensions.offsetX || 
                adjustedX > dimensions.offsetX + dimensions.streamWidth || 
                adjustedY < dimensions.offsetY || 
                adjustedY > dimensions.offsetY + dimensions.streamHeight
            ) {
                cursorOverlay.style.display = 'none';
            }
        });

        let currentPath = '/';
        let selectedItemPath = null;
        let selectedItem = null;

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        function formatDate(timestamp) {
            const date = new Date(timestamp);
            return date.toLocaleString();
        }

        const SVG_TEMPLATES = {
            upArrow: () => `
                <svg class="w-5 h-5 text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19V9m0 0-4 4m4-4 4 4"/>
                </svg>`,
            folder: (colorClass = 'text-blue-400') => `
                <svg class="w-5 h-5 ${colorClass}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z"/>
                </svg>`,
            file: () => `
                <svg class="w-5 h-5 text-green-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2h-2M9 5a2 2 0 0 0 2 2h2a2 2 0 0 0 2-2M9 5a2 2 0 0 1 2-2h2a2 2 0 0 1 2 2m-3 7h3m-3 4h3m-6-4h0m0 4h0"/>
                </svg>`,
            spinner: (size = 4) => `
                <svg class="animate-spin w-${size} h-${size}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke-width="4"/>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 0 1 8-8V0C5 0 0 5 0 12zm2 5a8 8 0 0 1-2-5H0c0 3 1 6 3 8z"/>
                </svg>`,
            upload: (size = 10, colorClass = 'text-blue-500/70') => `
                <svg class="w-${size} h-${size} mx-auto mb-2 ${colorClass}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 0 0 3 3h10a3 3 0 0 0 3-3v-1m-4-8-4-4m0 0L8 8m4-4v12"/>
                </svg>`,
            download: () => `
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v2a3 3 0 0 0 3 3h10a3 3 0 0 0 3-3v-2M12 3v12m0 0-4-4m4 4 4-4"/>
                </svg>`,
            delete: () => `
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18 18 6M6 6l12 12"/>
                </svg>`,
            rename: () => `
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 10h10a8 8 0 0 1 8 8v2M3 10l6 6m-6-6 6-6"/>
                </svg>`,
            createFolder: () => `
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"/>
                </svg>`
        };

        // Common CSS classes
        const CLASSES = {
            row: ['cursor-pointer', 'hover:bg-gray-700/50'],
            cell: ['px-4', 'py-2'],
            noAccess: ['opacity-50', 'cursor-not-allowed'],
            selected: 'bg-blue-500/50'
        };

        // Utility class to manage button loading states
        class LoadingButton {
            constructor(buttonId, loadingText = 'Loading...') {
                this.button = document.getElementById(buttonId);
                this.originalHtml = this.button.innerHTML;
                this.loadingText = loadingText;
            }

            startLoading() {
                this.button.disabled = true;
                this.button.innerHTML = `${SVG_TEMPLATES.spinner(4)} ${this.loadingText}`;
                return this;
            }

            stopLoading() {
                this.button.disabled = false;
                this.button.innerHTML = this.originalHtml;
                return this;
            }

            async withLoading(asyncFn) {
                this.startLoading();
                try {
                    await asyncFn();
                } finally {
                    this.stopLoading();
                }
            }
        }

        // Utility for drop zone states
        class DropZone {
            constructor(elementId) {
                this.element = document.getElementById(elementId);
                this.setupEventListeners();
            }

            setupEventListeners() {
                ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                    this.element.addEventListener(eventName, (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                    });
                });

                ['dragenter', 'dragover'].forEach(eventName => {
                    this.element.addEventListener(eventName, () => this.highlight());
                });

                ['dragleave', 'drop'].forEach(eventName => {
                    this.element.addEventListener(eventName, () => this.unhighlight());
                });
            }

            highlight() {
                this.element.classList.add('bg-blue-500/20', 'border-blue-700');
            }

            unhighlight() {
                this.element.classList.remove('bg-blue-500/20', 'border-blue-700');
            }

            setLoading() {
                this.element.innerHTML = `
                    <div class="text-center">
                        ${SVG_TEMPLATES.spinner(10)}
                        <p class="text-gray-400">Uploading files...</p>
                    </div>
                `;
            }

            reset() {
                this.element.innerHTML = `
                    <div class="text-center">
                        ${SVG_TEMPLATES.upload()}
                        <p class="text-gray-400">Drag and drop files here to upload</p>
                    </div>
                `;
            }
        }

        // Initialize buttons with loading states
        const downloadButton = new LoadingButton('downloadFile', 'Downloading...');
        const deleteButton = new LoadingButton('deleteItem', 'Deleting...');
        const renameButton = new LoadingButton('renameItem', 'Renaming...');
        const createFolderButton = new LoadingButton('createFolder', 'Creating...');
        const uploadButton = new LoadingButton('uploadFile', 'Uploading...');

        function clearSelection() {
            if (selectedItem) {
                selectedItem.classList.remove(CLASSES.selected);
                selectedItem = null;
                selectedItemPath = null;
            }
            
            const elements = ['downloadFile', 'deleteItem', 'renameInput', 'renameItem']
                .forEach(id => {
                    const element = document.getElementById(id);
                    element.disabled = true;
                    if (id === 'renameInput') element.value = '';
                });
        }

        function createCell(content, colSpan = 1) {
            const cell = document.createElement('td');
            cell.classList.add(...CLASSES.cell);
            if (colSpan > 1) cell.colSpan = colSpan;
            cell.innerHTML = content;
            return cell;
        }

        function createItemNameCell(item) {
            let iconTemplate = item.is_dir ? SVG_TEMPLATES.folder : SVG_TEMPLATES.file;
            let icon = item.is_dir && item.no_access ? iconTemplate('text-gray-500') : iconTemplate();
            return `<div class="flex items-center gap-2">${icon}${item.name}</div>`;
        }

        function getParentPath(currentPath) {
            if (currentPath.match(/^[A-Z]:\\$/)) {
                return '/';
            }
            const path = currentPath.endsWith('\\') ?
                currentPath.substring(0, currentPath.length - 1) :
                currentPath;
            return path.substring(0, path.lastIndexOf('\\')) + '\\';
        }

        function createTableRow(classes = []) {
            const row = document.createElement('tr');
            row.classList.add(...CLASSES.row, ...classes);
            return row;
        }

        function handleItemSelection(row, item) {
            return (event) => {
                const isDirectoryNameCell = event.target.classList.contains('name-cell') && item.is_dir;

                if (isDirectoryNameCell) {
                    return;
                }

                if (selectedItem) {
                    selectedItem.classList.remove(CLASSES.selected);
                }
                if (selectedItem === row) {
                    clearSelection();
                } else {
                    row.classList.add(CLASSES.selected);
                    selectedItem = row;
                    selectedItemPath = item.path;
                    document.getElementById('fileOperations').classList.remove('hidden');

                    ['downloadFile', 'deleteItem', 'renameInput', 'renameItem'].forEach(id => {
                        const element = document.getElementById(id);
                        element.disabled = false;
                        if (id === 'renameInput') element.value = item.name;
                    });

                    document.getElementById('downloadFile').disabled = item.is_dir;
                }
            };
        }

        function handleItemDoubleClick(item) {
            return () => {
                if (item.is_dir && !item.no_access) {
                    listFiles(item.path);
                }
            };
        }

        function createUpDirectoryRow(currentPath) {
            const row = createTableRow();
            row.addEventListener('click', () => listFiles(getParentPath(currentPath)));
            
            const nameCell = createCell(
                `<div class="flex items-center gap-2">${SVG_TEMPLATES.upArrow()}..</div>`,
                3
            );
            row.appendChild(nameCell);
            return row;
        }

        async function listFiles(path) {
            clearSelection();
            const fileList = document.getElementById('fileList');
            fileList.innerHTML = `<tr><td colspan="3" class="p-4 text-center text-gray-400">Loading...</td></tr>`;

            try {
                const response = await apiCall(`/api/files?path=${encodeURIComponent(path)}`);
                
                if (response.status === 'error') {
                    fileList.innerHTML = `<tr><td colspan="3" class="p-4 text-center text-red-500">${response.message}</td></tr>`;
                    if (response.no_access && path !== '/') {
                        fileList.appendChild(createUpDirectoryRow(path));
                    }
                    return;
                }

                fileList.innerHTML = '';
                currentPath = path;
                document.getElementById('currentPath').textContent = `Current Path: ${currentPath}`;

                if (path !== '/') {
                    fileList.appendChild(createUpDirectoryRow(currentPath));
                }

                for (const item of response) {
                    const row = createTableRow(item.no_access ? CLASSES.noAccess : []);

                    row.addEventListener('click', handleItemSelection(row, item));

                    row.addEventListener('dblclick', handleItemDoubleClick(item));

                    const nameCell = createCell(createItemNameCell(item));

                    nameCell.classList.add('name-cell');

                    if (item.no_access) {
                        row.classList.add(...CLASSES.noAccess);
                    }

                    row.appendChild(nameCell);

                    if (item.is_dir) {
                        row.appendChild(createCell('-'));
                        row.appendChild(createCell('-'));
                    } else {
                        const stats = await apiCall(`/api/file_info?path=${encodeURIComponent(item.path)}`);
                        row.appendChild(createCell(formatFileSize(stats.size)));
                        row.appendChild(createCell(formatDate(stats.last_modified)));
                    }

                    fileList.appendChild(row);
                }
            } catch (error) {
                console.error('Error listing files:', error);
                fileList.innerHTML = `<tr><td colspan="3" class="p-4 text-center text-red-500">Error: ${error.message}</td></tr>`;
            }
        }

        // File download
        document.getElementById('downloadFile').addEventListener('click', () =>
            downloadButton.withLoading(async () => {
                if (!selectedItemPath) {
                    alert('Please select a file to download');
                    return;
                }
                try {
                    const url = `/api/download?path=${encodeURIComponent(selectedItemPath)}`;
                    const link = document.createElement('a');
                    link.href = url;
                    link.setAttribute('download', '');
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                } catch (error) {
                    console.error('Error downloading file:', error);
                    alert('Error downloading file');
                }
            })
        );

        // File upload
        document.getElementById('uploadFile').addEventListener('click', () =>
            uploadButton.withLoading(async () => {
                const fileInput = document.getElementById('fileUpload');
                if (fileInput.files.length === 0) {
                    alert('Please select a file to upload');
                    return;
                }

                const formData = new FormData();
                for (let i = 0; i < fileInput.files.length; i++) {
                    formData.append('files', fileInput.files[i]);
                }
                formData.append('path', currentPath);

                try {
                    const response = await fetch('/api/upload', {
                        method: 'POST',
                        body: formData
                    });
                    const result = await response.json();
                    if (result.status === 'success') {
                        alert('File uploaded successfully');
                        listFiles(currentPath);
                        fileInput.value = '';
                        document.getElementById('selectedFileName').textContent = 'No file chosen';
                    } else {
                        alert(result.message);
                    }
                } catch (error) {
                    console.error('Error uploading file:', error);
                    alert('Error uploading file');
                }
            })
        );

        // File/folder deletion
        document.getElementById('deleteItem').addEventListener('click', () =>
            deleteButton.withLoading(async () => {
                if (!selectedItemPath) {
                    alert('Please select a file or folder to delete');
                    return;
                }

                if (!confirm(`Are you sure you want to delete ${selectedItemPath}?`)) {
                    return;
                }

                try {
                    const response = await apiCall('/api/delete', 'POST', { path: selectedItemPath });
                    if (response.status === 'success') {
                        alert('Item deleted successfully');
                        listFiles(currentPath);
                        document.getElementById('fileOperations').classList.add('hidden');
                        selectedItemPath = null;
                    } else {
                        alert(response.message);
                    }
                } catch (error) {
                    console.error('Error deleting item:', error);
                    alert('Error deleting item');
                }
            })
        );

        // Folder creation
        document.getElementById('createFolder').addEventListener('click', () =>
            createFolderButton.withLoading(async () => {
                const folderName = document.getElementById('newFolderName').value.trim();
                if (!folderName) {
                    alert('Please enter a folder name');
                    return;
                }

                try {
                    const response = await apiCall('/api/create_folder', 'POST', { parentPath: currentPath, folderName });
                    if (response.status === 'success') {
                        alert('Folder created successfully');
                        listFiles(currentPath);
                        document.getElementById('newFolderName').value = '';
                    } else {
                        alert(response.message);
                    }
                } catch (error) {
                    console.error('Error creating folder:', error);
                    alert('Error creating folder');
                }
            })
        );

        // File/folder renaming
        document.getElementById('renameItem').addEventListener('click', () =>
            renameButton.withLoading(async () => {
                const newName = document.getElementById('renameInput').value.trim();
                if (!selectedItemPath || !newName) {
                    alert('Please select a file or folder and enter a new name');
                    return;
                }

                try {
                    const response = await apiCall('/api/rename', 'POST', { oldPath: selectedItemPath, newName });
                    if (response.status === 'success') {
                        alert('Item renamed successfully');
                        listFiles(currentPath);
                        document.getElementById('fileOperations').classList.add('hidden');
                        selectedItemPath = null;
                        document.getElementById('renameInput').value = '';
                    } else {
                        alert(response.message);
                    }
                } catch (error) {
                    console.error('Error renaming item:', error);
                    alert('Error renaming item');
                }
            })
        );

        // Setup drop zone
        const dropZone = new DropZone('dropZone');

        dropZone.element.addEventListener('drop', async (e) => {
            const files = e.dataTransfer.files;
            if (files.length === 0) return;

            const formData = new FormData();
            for (let i = 0; i < files.length; i++) {
                formData.append('files', files[i]);
            }
            formData.append('path', currentPath);

            dropZone.setLoading();

            try {
                const response = await fetch('/api/upload', {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();
                if (result.status === 'success') {
                    alert('Files uploaded successfully');
                    listFiles(currentPath);
                } else {
                    alert(result.message);
                }
            } catch (error) {
                console.error('Error uploading files:', error);
                alert('Error uploading files');
            } finally {
                dropZone.reset();
            }
        });

        function updateSelectedFileName(input) {
            const selectedFileName = document.getElementById('selectedFileName');
            selectedFileName.textContent = input.files.length > 1 ? `${input.files.length} files selected` : input.files[0]?.name || 'No file chosen';
            selectedFileName.classList.toggle('text-gray-400', input.files.length === 0);
            selectedFileName.classList.toggle('text-green-400', input.files.length > 0);
        }

        listFiles(currentPath);

    </script>
</body>
</html>